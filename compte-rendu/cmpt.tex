\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx} % Required for inserting images
\usepackage[letterpaper,margin=3cm]{geometry}
\usepackage[export]{adjustbox}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{svg}
\usepackage{tocloft}
\usepackage{algorithmic}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{array}
\usepackage{float}
\usepackage{caption}

\renewcommand{\thesection}{\Roman{section}} 
\renewcommand\thesubsection{\arabic{subsection}}

\setlength{\cftsecnumwidth}{3em} 
% ajuste la largeur de la colonne des numéros de section

\setlength{\parindent}{1cm}
\sloppy


%--- begin document ------------------------------------------------------------

\title{Projet de raisonnement propositionnel}
\author{Edouard.H Théo.R.V}
\date{2022--2023}

\begin{document}
    \begin{figure}
        \includegraphics[scale=0.3, right]{logo-univ-rouen-normandie-noir.png}
    \end{figure}

    \maketitle

    \begin{abstract}
        Ce document constitue notre compte rendu du projet de raisonnement
        propositionnel traitent d'une implémentation de la méthode des 
        tableaux et de fonction de test. Il s'agit d'une méthode permettant de 
        déterminer la satisfesabiliter d'une formule booléenne. Les fonctions de 
        test permettent de vérifier empiriquement l'implémentation de la méthode.  
        
        Dans un premier temps, nous présenterons notre implémentation de la 
        méthode des tableaux et des divers choix présent dans celle-ci. Pour 
        finir, nous aborderons les difficultés liées à la production de ce 
        projet.
    \end{abstract}

    \newpage

    \tableofcontents

    \newpage

    \section{Implémentation de la méthode des tableaux}

    \subsection{Formule}

    Tout d'abord, nous avons dès le début de la conception de ce projet mis en 
    place les opérateurs étendus vus en TD.\@ On peut notamment citée les 
    opérateurs, \textbf{xor}, \textbf{nor}, \textbf{nand}, \textbf{diff} et 
    \textbf{equiv} de symbole respectif $\oplus$, $\uparrow$, $\downarrow$, 
    $\setminus$ et $\Leftrightarrow$. 

    \vphantom{}

    La fonction \textbf{string\_of\_formule} est une fonction récursive non 
    terminale, ce choix est dû à plusieurs raisons. La première étant que sa 
    complexité espace sera logarithmique par la division de la formule par deux
    a chaque appel récursif. La deuxième raison réside dans l'hypothèse que les
    formule afficher ne devrais pas être d'une taille démesurée enfaite une 
    formule trop grande ne pourrait pas être affichée sur un terminal de taille
    standard. De plus ce choix favorise la compréhension de cette fonction.

    \vphantom{}

    En ce qui concerne la fonction \textbf{eval} ayant déjà implémenté la
    partie de `base' en TP tout le travail, c'est focaliser sur les opérateurs
    étendus. Ces opérations n'étant pas implémenté de façon standard en Ocaml,
    nous avons donc à partir des tables de vérités mises en place des formules 
    équivalente permettant alors leur implémentation, voir 
    table~\ref{tab:tab-verite} pour les formules équivalente résultant des 
    tables de vérités.  

    \begin{table}[H]
        \centering
        \hfill
        $\begin{array}{c c c}
            \hline
            a & b & a \oplus b\\
            \hline
            0 & 0 & 0\\
            0 & 1 & 1\\
            1 & 0 & 1\\
            1 & 1 & 0\\
            \hline
            \multicolumn{3}{c}{(a \setminus b) \lor (b \setminus a)}
        \end{array}
        \hfill
        \begin{array}{c c c}
            \hline
            a & b & a \uparrow b\\
            \hline
            0 & 0 & 1\\
            0 & 1 & 1\\
            1 & 0 & 1\\
            1 & 1 & 0\\
            \hline
            \multicolumn{3}{c}{\lnot (a \land b)}
        \end{array}
        \hfill
        \begin{array}{c c c}
            \hline
            a & b & a \downarrow b\\
            \hline
            0 & 0 & 1\\
            0 & 1 & 0\\
            1 & 0 & 0\\
            1 & 1 & 0\\
            \hline
            \multicolumn{3}{c}{\lnot (a \lor b)}
        \end{array}
        \hfill
        \begin{array}{c c c}
            \hline
            a & b & a \setminus b\\
            \hline
            0 & 0 & 0\\
            0 & 1 & 1\\
            1 & 0 & 1\\
            1 & 1 & 0\\
            \hline
            \multicolumn{3}{c}{a \lor b}
        \end{array}
        \hfill
        \begin{array}{c c c}
            \hline
            a & b & a \Leftrightarrow b\\
            \hline
            0 & 0 & 0\\
            0 & 1 & 1\\
            1 & 0 & 1\\
            1 & 1 & 0\\
            \hline
            \multicolumn{3}{c}{(a \to b) \land (b \to a)}
        \end{array}$
        \hfill
        \captionsetup{position=bottom}
        \caption{Tables de vérités et formule équivalente.}\label{tab:tab-verite} 
    \end{table}

    \subsection{RandomFormule}

    Pour la fonction \textbf{random\_form}, nous avons fait le choix de la divisée en 
    plusieurs sous-fonctions. Un tel choix permet une compréhension plus
    aisée du traitement effectué dans la fonction. Les quatre fonctions 
    \textbf{random\_atome}, \textbf{random\_n\_operator}, 
    \textbf{random\_u\_operator} et \textbf{random\_b\_operator} corresponde 
    chacune à l'obtention d'un élément de façon pseudo-aléatoire, un atome, un 
    opérateur nullaire, unaire et binaire respectivement aux fonctions citées plus 
    haut. Une telle division permet aussi de facilité un possible futur ajout 
    d'opérateurs, d'où la création d'une fonction pour obtenir un opérateur 
    unaire de façon aléatoire bien qu'il n'aille qu'un seul. Toutes les autres 
    fonctions obtiennent l'élément cible en tirant un nombre pseudo-aléatoire à 
    l'aide du module \textbf{Random}. L'algorithme utilisé pour la génération de 
    cette formule pseudo-aléatoire est celui donné dans le sujet du projet.

    \subsection{Tableaux}

    Toutes les fonctions implémentées dans le fichier source \textbf{Tableaux.ml}, 
    résulte de l'implémentation de la méthode des tableaux.   

    \vphantom{}

    Pour les fonctions \textbf{tableau\_sat} et \textbf{tableau\_ex\_sat}, nous 
    avons réunies ces traitement en une seule fonction auxiliaire \textbf{tab\_methode}.
    Elle renvoie un couple de booléen et d'une liste, d'atome list prouvant sa 
    satisfaisabilité dans le cas ou la formule f l'est. C'est une fonction récursive
    non-terminal (car supposant que les formules ont des tailles raisonnable), qui 
    itère sur la liste de formule qu'il lui reste à traiter. En effet, la méthode 
    des tableaux décompose une formule pour construire un arbre permettant de 
    déterminer la satisfaisabilité de cette formule. L'itération sur la liste de 
    formule permet comme décrite dans la méthode d'ajouter en bout de `branche'
    les formules à traiter par la suite. Comme décris dans cette méthode, l'opérateur
    \textbf{bot} conclue à une fermeture de branche, c'est-à-dire que cette 
    branche ne peut pas être satisfaisable d'où le retours pour cette branche de 
    la valeur \textbf{false} et d'une liste d'atomes vide. Pour le cas de 
    \textbf{Top}, la fonction passe à la prochaine sous-formule à traiter en 
    conservant les atomes rencontrée précédemment. En cas de rencontre d'un 
    atome qu'il s'agisse de sa négation ou non, une recherche dans la liste d'atome
    déjà rencontrée permet de savoir si sa négation est présente, dans ce cas 
    la branche est fermé (donc de mêmes retours que pour l'opérateur \textbf{bot})
    sinon l'ajoute à la liste d'atome puis effectué le prochain traitement. La 
    rencontre d'une conjonction et d'une négation de disjonction, entraine 
    l'ajout en tête de liste des deux opérandes et de leurs négation 
    respectivement et continue le traitement.
    En ce qui concerne la disjonction et la négation de conjonction, nous créons 
    un `nœud' à la fin de la branche. Ce `nœud' est représenté par une première
    exécution de la branche avec en tête de celle-ci la sous-formule correspondent 
    au premier opérande. Si cette exécution renvoie vrai alors la formule est 
    satisfaisable donc on arrête le traitement sinon le programme exécute une nouvelle 
    fois cette branche, mais avec en tête cette fois-ci la deuxième opérande. Pour 
    finir en cas d'apparition d'un opérateur étendu, un appelé à la fonction 
    \textbf{transform} permet d'exprimer cette opérande en fonction des opérateurs
    dont le traitement est cité ci-dessus.

    En ce qui concerne la fonction \textbf{tableau\_all\_sat}, le traitement de 
    tous les opérateurs est identique à celui de la fonction \textbf{tab\_methode}
    sauf pour la disjonction. En effet, devant renvoyer touts les atomes de toutes 
    les branches, de ce fait toutes les branches sont traité pour les disjonctions
    et don  une concaténation de liste permet d'obtenir tous ces atomes.

    \subsection{Test}

    La fonction \textbf{to\_alea\_inter}, a été implémentée à l'aide d'une 
    fonction auxiliaire qui sera renvoyer à l'utilisateur partiellement 
    exécuter (sans tous ces paramètres, pour renvoyer une fonction de type 
    interprétation). On peut remarquer l'utilisation de la fonction 
    \textbf{List.assoc\_opt}, qui permet de rechercher dans une liste de couple 
    clé valeur (a, b) la valeur de b qui corresponds à la valeur de clé passer en 
    paramètres. On remarque quelle renvoie \textbf{None} en cas d'échec et 
    \textbf{Some b} en cas succès.

    \vphantom{}

    Pour la fonction \textbf{test\_valid}, nous utilisont des sous-fonctions 
    \textbf{ex\_sat}, \textbf{all\_sat}. Chacune visent à vérifier la véracité
    des retours des fonctions \textbf{tableau\_ex\_sat} et 
    \textbf{tableau\_all\_sat} respectivement.

    \section{Les difficultés rencontrées}
    
    \section{Conclusion}

\end{document}